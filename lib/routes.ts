/*
File generated by js-routes RubyVariables.GEM_VERSION
Based on Rails RubyVariables.RAILS_VERSION routes of RubyVariables.APP_CLASS
 */

type NodeType = number;
type RouteParameter = any;
type RouteParameters = Record<string, RouteParameter>;
type Serializer = (object: any) => string;
type RouteHelper = {
  (...args: RouteParameter[]): string;
  required_params: string[];
  toString(): string;
};

declare const RubyVariables: {
  PREFIX: string;
  NODE_TYPES: Record<string, NodeType>;
  DEPRECATED_GLOBBING_BEHAVIOR: boolean;
  SPECIAL_OPTIONS_KEY: string;
  DEFAULT_URL_OPTIONS: RouteParameters;
  SERIALIZER: Serializer;
  NAMESPACE: string;
  ROUTES: any;
};

declare const exports: any;
declare const define:
  | undefined
  | (Function & { amd?: (args: any[], callback: () => any) => void });

type Configuration = {
  prefix: string;
  default_url_options: RouteParameters;
  special_options_key: string;
  serializer?: Serializer;
};

type Optional<T> = { [P in keyof T]?: T[P] | null };

(function (that: any) {
  enum NodeTypes {
    GROUP = 1,
    CAT = 2,
    SYMBOL = 3,
    OR = 4,
    STAR = 5,
    LITERAL = 6,
    SLASH = 7,
    DOT = 8,
  }
  type RouteTree =
    | [NodeTypes.GROUP, RouteTree, never]
    | [NodeTypes.STAR, RouteTree, never]
    | [NodeTypes.LITERAL, string, never]
    | [NodeTypes.SLASH, "/", never]
    | [NodeTypes.DOT, ".", never]
    | [NodeTypes.CAT, RouteTree, RouteTree]
    | [NodeTypes.SYMBOL, string, never];

  const hasProp = {}.hasOwnProperty;
  const Root = typeof exports === "object" ? exports : that;

  class ParameterMissing extends Error {
    constructor(message: string) {
      super(message);
      Object.setPrototypeOf(this, Object.getPrototypeOf(this));
    }
  }

  const DeprecatedGlobbingBehavior = RubyVariables.DEPRECATED_GLOBBING_BEHAVIOR;

  const SpecialOptionsKey = RubyVariables.SPECIAL_OPTIONS_KEY;

  const UriEncoderSegmentRegex = /[^a-zA-Z0-9\-\._~!\$&'\(\)\*\+,;=:@]/g;

  const ReservedOptions = [
    "anchor",
    "trailing_slash",
    "subdomain",
    "host",
    "port",
    "protocol",
  ] as const;

  const DefaultConfiguration: Configuration = {
    prefix: RubyVariables.PREFIX,
    default_url_options: RubyVariables.DEFAULT_URL_OPTIONS,
    special_options_key: RubyVariables.SPECIAL_OPTIONS_KEY,
    serializer: RubyVariables.SERIALIZER,
  };

  class UtilsClass {
    configuration: Configuration = DefaultConfiguration;

    default_serializer(object: any, prefix?: string): string {
      if (object == null) {
        return "";
      }
      if (!prefix && !(this.get_object_type(object) === "object")) {
        throw new Error("Url parameters should be a javascript hash");
      }
      const s: string[] = [];
      switch (this.get_object_type(object)) {
        case "array":
          for (const element of object) {
            s.push(this.default_serializer(element, prefix + "[]"));
          }
          break;
        case "object":
          for (let key in object) {
            if (!hasProp.call(object, key)) continue;
            let prop = object[key];
            if (prop == null && prefix) {
              prop = "";
            }
            if (prop != null) {
              if (prefix) {
                key = prefix + "[" + key + "]";
              }
              s.push(this.default_serializer(prop, key));
            }
          }
          break;
        default:
          if (object != null) {
            s.push(
              encodeURIComponent(prefix!.toString()) +
                "=" +
                encodeURIComponent(object.toString())
            );
          }
      }
      if (!s.length) {
        return "";
      }
      return s.join("&");
    }
    serialize(object: any): string {
      const custom_serializer = this.configuration.serializer;
      if (custom_serializer) {
        return custom_serializer(object);
      } else {
        return this.default_serializer(object);
      }
    }
    clean_path(path: string): string {
      const tokens = path.split("://");
      const last_index = tokens.length - 1;
      tokens[last_index] = tokens[last_index].replace(/\/+/g, "/");
      return tokens.join("://");
    }
    extract_options(number_of_params: number, args: object[]): RouteParameters {
      const last_el = args[args.length - 1];
      if (
        (args.length > number_of_params && last_el === void 0) ||
        (last_el != null &&
          "object" === this.get_object_type(last_el) &&
          !this.looks_like_serialized_model(last_el))
      ) {
        const options: RouteParameters = args.pop() || {};
        delete options[this.configuration.special_options_key];
        return options;
      } else {
        return {};
      }
    }
    looks_like_serialized_model(
      object: any
    ): object is { id: any } | { to_param: any } {
      return (
        !object[this.configuration.special_options_key] &&
        ("id" in object || "to_param" in object)
      );
    }
    path_identifier(
      object: 0 | Record<string, any> | { toString(): string }
    ): string {
      if (object === 0) {
        return "0";
      }
      if (!object) {
        return "";
      }
      let property: any = object;
      if (this.get_object_type(object) === "object") {
        if ("to_param" in object) {
          if (object.to_param == null) {
            throw new ParameterMissing("Route parameter missing: to_param");
          }
          property = object.to_param;
        } else if ("id" in object) {
          if (object.id == null) {
            throw new ParameterMissing("Route parameter missing: id");
          }
          property = object.id;
        } else {
          property = object;
        }
        if (this.get_object_type(property) === "function") {
          property = property.call(object);
        }
      }
      return property.toString();
    }

    normalize_options(
      parts: string[],
      required_parts: string[],
      default_options: RouteParameters,
      call_arguments: any[]
    ) {
      let options = this.extract_options(parts.length, call_arguments);
      if (call_arguments.length > parts.length) {
        throw new Error("Too many parameters provided for path");
      }
      let use_all_parts = call_arguments.length > required_parts.length;
      const parts_options: RouteParameters = {};
      for (const key in options) {
        const value = options[key];
        if (!hasProp.call(options, key)) continue;
        use_all_parts = true;
        if (this.indexOf(parts, key) >= 0) {
          parts_options[key] = value;
        }
      }
      options = {
        ...this.configuration.default_url_options,
        ...default_options,
        ...options,
      };
      const result: RouteParameters = {};
      const url_parameters: RouteParameters = {};
      result["url_parameters"] = url_parameters;
      for (const key in options) {
        if (!hasProp.call(options, key)) continue;
        const value = options[key];
        if (this.indexOf(ReservedOptions, key) >= 0) {
          result[key] = value;
        } else {
          url_parameters[key] = value;
        }
      }
      const route_parts = use_all_parts ? parts : required_parts;
      let i = 0;
      for (const part of route_parts) {
        if (i < call_arguments.length) {
          if (!parts_options.hasOwnProperty(part)) {
            url_parameters[part] = call_arguments[i];
            ++i;
          }
        }
      }
      return result;
    }
    build_route(
      parts: string[],
      required_parts: string[],
      default_options: RouteParameters,
      route: RouteTree,
      full_url: boolean,
      args: RouteParameter[]
    ): string {
      args = [...args];
      const options = this.normalize_options(
        parts,
        required_parts,
        default_options,
        args
      );
      const parameters = options["url_parameters"];
      const result = this.get_prefix() + this.visit(route, parameters);
      let url = this.clean_path(result);
      if (options["trailing_slash"] === true) {
        url = url.replace(/(.*?)[\/]?$/, "$1/");
      }
      const url_params = this.serialize(parameters);
      if (url_params.length) {
        url += "?" + url_params;
      }
      url += options.anchor ? "#" + options.anchor : "";
      if (full_url) {
        url = this.route_url(options) + url;
      }
      return url;
    }
    visit(
      route: RouteTree,
      parameters: RouteParameters,
      optional: boolean = false
    ): string {
      switch (route[0]) {
        case NodeTypes.GROUP:
          return this.visit(route[1], parameters, true);
        case NodeTypes.STAR:
          return this.visit_globbing(route[1], parameters, true);
        case NodeTypes.LITERAL:
        case NodeTypes.SLASH:
        case NodeTypes.DOT:
          return route[1];
        case NodeTypes.CAT:
          const [_, left, right] = route;
          const left_part = this.visit(left, parameters, optional);
          const right_part = this.visit(right, parameters, optional);
          if (
            optional &&
            ((this.is_optional_node(left[0]) && !left_part) ||
              (this.is_optional_node(right[0]) && !right_part))
          ) {
            return "";
          }
          return "" + left_part + right_part;
        case NodeTypes.SYMBOL:
          const key = route[1];
          const value = parameters[key];
          delete parameters[key];
          if (value != null) {
            return this.encode_segment(this.path_identifier(value));
          }
          if (optional) {
            return "";
          } else {
            throw new ParameterMissing("Route parameter missing: " + key);
          }
          break;
        default:
          throw new Error("Unknown Rails node type");
      }
    }
    encode_segment(segment: string): string {
      return segment.replace(UriEncoderSegmentRegex, function (str) {
        return encodeURIComponent(str);
      });
    }
    is_optional_node(node: NodeTypes): boolean {
      return (
        this.indexOf([NodeTypes.STAR, NodeTypes.SYMBOL, NodeTypes.CAT], node) >=
        0
      );
    }
    build_path_spec(route: RouteTree, wildcard: boolean = false): string {
      switch (route[0]) {
        case NodeTypes.GROUP:
          return "(" + this.build_path_spec(route[1]) + ")";
        case NodeTypes.CAT:
          return (
            this.build_path_spec(route[1]) + this.build_path_spec(route[2])
          );
        case NodeTypes.STAR:
          return this.build_path_spec(route[1], true);
        case NodeTypes.SYMBOL:
          const key = route[1];
          if (wildcard === true) {
            return (key.startsWith("*") ? "" : "*") + key;
          } else {
            return ":" + key;
          }
          break;
        case NodeTypes.SLASH:
        case NodeTypes.DOT:
        case NodeTypes.LITERAL:
          return route[1];
        default:
          throw new Error("Unknown Rails node type");
      }
    }
    visit_globbing(
      route: RouteTree,
      parameters: RouteParameters,
      optional: boolean
    ): string {
      const key = route[1] as string;
      let value = parameters[key];
      delete parameters[key];
      if (value == null) {
        return this.visit(route, parameters, optional);
      }
      if (this.get_object_type(value) === "array") {
        value = value.join("/");
      }
      if (DeprecatedGlobbingBehavior) {
        return this.path_identifier(value);
      } else {
        return encodeURI(this.path_identifier(value));
      }
    }
    get_prefix(): string {
      const prefix = this.configuration.prefix;
      if (prefix !== "") {
        return prefix.match("/$") ? prefix : prefix + "/";
      }
      return prefix;
    }
    route(
      parts_table: [string, boolean][],
      default_options: RouteParameters,
      route_spec: RouteTree,
      full_url: boolean
    ): RouteHelper {
      const required_parts: string[] = [];
      const parts: string[] = [];
      for (const [part, required] of parts_table) {
        parts.push(part);
        if (required) {
          required_parts.push(part);
        }
      }
      const result = (...args: RouteParameter[]): string => {
        return this.build_route(
          parts,
          required_parts,
          default_options,
          route_spec,
          full_url,
          args
        );
      };
      result.required_params = required_parts;
      result.toString = () => {
        return this.build_path_spec(route_spec);
      };
      return result;
    }
    route_url(
      route_defaults: Optional<{
        host: string;
        protocol: string;
        subdomain: string;
        port: string;
      }>
    ): string {
      const hostname = route_defaults.host || this.current_host();
      if (!hostname) {
        return "";
      }
      const subdomain = route_defaults.subdomain
        ? route_defaults.subdomain + "."
        : "";
      const protocol = route_defaults.protocol || this.current_protocol();
      let port =
        route_defaults.port ||
        (!route_defaults.host ? this.current_port() : undefined);
      port = port ? ":" + port : "";
      return protocol + "://" + subdomain + hostname + port;
    }

    has_location(): boolean {
      return (
        typeof window !== "undefined" && window !== null && !!window.location
      );
    }
    current_host(): string | null {
      if (this.has_location()) {
        return window.location.hostname;
      } else {
        return null;
      }
    }
    current_protocol(): string {
      if (this.has_location() && window.location.protocol !== "") {
        return window.location.protocol.replace(/:$/, "");
      } else {
        return "http";
      }
    }
    current_port(): string {
      if (this.has_location() && window.location.port !== "") {
        return window.location.port;
      } else {
        return "";
      }
    }
    _classToTypeCache = "Boolean Number String Function Array Date RegExp Object Error"
      .split(" ")
      .reduce(
        (result, name) => ({
          ...result,
          [`[object ${name}]`]: name.toLowerCase(),
        }),
        {}
      );

    get_object_type(obj: any) {
      if (obj == null) {
        return "" + obj;
      }
      if (typeof obj === "object" || typeof obj === "function") {
        return (
          this._classToTypeCache[Object.prototype.toString.call(obj)] ||
          "object"
        );
      } else {
        return typeof obj;
      }
    }
    indexOf<T>(array: readonly T[], element: T): number {
      if (array.indexOf) {
        return array.indexOf(element);
      } else {
        return this.indexOfImplementation(array, element);
      }
    }

    indexOfImplementation<T>(array: readonly T[], element: T): number {
      let result = -1;
      array.forEach((el, i) => {
        if (el === element && result === -1) {
          result = i;
        }
      });
      return result;
    }

    namespace(
      object: object,
      namespace: string | null | undefined,
      routes: unknown
    ): unknown {
      const parts = namespace ? namespace.split(".") : [];
      if (parts.length === 0) {
        return routes;
      }
      for (let index = 0; index < parts.length; index++) {
        const part = parts[index];
        if (index < parts.length - 1) {
          object = object[part] || (object[part] = {});
        } else {
          return (object[part] = routes);
        }
      }
    }

    configure(new_config: Partial<Configuration>): Configuration {
      this.configuration = { ...this.configuration, ...new_config };
      return this.configuration;
    }

    config(): Configuration {
      return { ...this.configuration };
    }
    make(): void {
      const routes = RubyVariables.ROUTES;
      routes.configure = (config: Partial<Configuration>) => {
        return this.configure(config);
      };
      routes.config = () => {
        return this.config();
      };
      routes.default_serializer = (object: object, prefix: string = "") => {
        return this.default_serializer(object, prefix);
      };
      this.namespace(Root, RubyVariables.NAMESPACE, routes);
      return Object.assign(
        {
          default: routes,
        },
        routes
      );
    }
  }

  const Utils = new UtilsClass();
  const result = Utils.make();

  if (typeof define === "function" && define.amd) {
    define([], function () {
      return result;
    });
  }

  return result;
})(this);
